<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>China Housing Price Decline</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link
    rel="stylesheet"
    href="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.css"
  />
  <style>
    body { margin: 0; font-family: Arial, sans-serif; }
    #map { height: 100vh; }

    .info-panel {
      position: absolute; top: 10px; right: 10px; z-index: 1000;
      background: #fff; padding: 14px; border-radius: 10px;
      box-shadow: 0 2px 10px rgba(0,0,0,.08); max-width: 320px;
    }
    .legend {
      position: absolute; bottom: 30px; right: 10px; z-index: 1000;
      background: #fff; padding: 12px; border-radius: 10px;
      box-shadow: 0 2px 10px rgba(0,0,0,.08);
    }
    .legend-item { display: flex; align-items: center; margin: 4px 0; font-size: 12px; }
    .legend-color { width: 20px; height: 15px; margin-right: 8px; border: 1px solid #ddd; }

    .top10-panel {
      position: absolute; left: 10px; bottom: 30px; z-index: 1000;
      background: #fff; padding: 12px; border-radius: 10px;
      box-shadow: 0 2px 10px rgba(0,0,0,.08); max-width: 320px;
    }
    .top10-panel ol { margin: 6px 0 0; padding-left: 18px; max-height: 220px; overflow:auto; }
  </style>
</head>
<body>
  <!-- Right info panel -->
  <div class="info-panel">
    <h3 style="margin:0 0 10px 0;">China Housing Price Decline</h3>
    <div>
      <strong>Analysis Overview</strong><br/>
      <span id="dataStatus">Loading data‚Ä¶</span>
    </div>
    <div class="stats" id="statsPanel" style="margin-top:8px; padding-top:8px; border-top:1px solid #eee; font-size:12px; color:#666; display:none;">
      <div id="averageDecline"></div>
      <div id="severeDeclines"></div>
      <div id="nearPeaks"></div>
    </div>
  </div>

  <!-- Right legend -->
  <div class="legend" id="legendBox">
    <h4 style="margin: 0 0 10px 0;">Decline from Peak (%)</h4>
    <!-- Items will be injected by JS -->
  </div>

  <!-- Left bottom Top10 -->
  <div class="top10-panel">
    <h4 style="margin:0 0 6px 0;">Top 10 Cities by Decline</h4>
    <ol id="top10List"></ol>
  </div>

  <div id="map"></div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.min.js"></script>
  <script>
    // ======= CONFIG =======
    const GEOJSON = "peak_decline_boundaries_simplified.geojson";

    // Blues (light ‚Üí dark), plus a red for "new high"
    // Palette based on ColorBrewer Blues with finer bins.
    const COLOR_BINS = [
      { label: "New High (+5%)", color: "#8B0000", key: "newhigh" },   // special case when value >= +5 (above peak)
      { label: "0‚Äì5% decline",   color: "#f7fbff", min: 0,  max: 5  },
      { label: "5‚Äì10% decline",  color: "#deebf7", min: 5,  max: 10 },
      { label: "10‚Äì15%",         color: "#c6dbef", min: 10, max: 15 },
      { label: "15‚Äì20%",         color: "#9ecae1", min: 15, max: 20 },
      { label: "20‚Äì25%",         color: "#6baed6", min: 20, max: 25 },
      { label: "25‚Äì30%",         color: "#4292c6", min: 25, max: 30 },
      { label: "30‚Äì35%",         color: "#2171b5", min: 30, max: 35 },
      { label: "35‚Äì40%",         color: "#08519c", min: 35, max: 40 },
      { label: "‚â• 40%",          color: "#08306b", min: 40, max: Infinity }
    ];

    // Helpers to get city name & decline value from feature properties
    function getCityName(p) {
      return p.city_en || p.city || p.name || "Unknown";
    }
    function getRawDecline(p) {
      // Many datasets store decline as negative numbers.
      // Prefer capped if present; else use original.
      let v = (typeof p.decline_from_peak_capped === "number")
                ? p.decline_from_peak_capped
                : p.decline_from_peak;
      return (typeof v === "number") ? v : null;
    }
    function toDropMagnitude(raw) {
      // Convert raw (often negative) to positive "drop %" for ranking/color
      // raw >= 0 means near peak or new high; treat drop=0 in that case.
      if (raw === null) return { drop: null, newHigh: false };
      if (raw >= 5) return { drop: 0, newHigh: true }; // clear new high
      if (raw >= 0) return { drop: 0, newHigh: false }; // near peak
      return { drop: -raw, newHigh: false }; // negative ‚Üí positive magnitude
    }

    function getColorForValue(raw) {
      const { drop, newHigh } = toDropMagnitude(raw);
      if (newHigh) return "#8B0000";          // dark red for new highs
      if (drop === null) return "#CCCCCC";    // no data
      // Match drop against bins (0..5, 5..10, ..., ‚â•40)
      for (let i = 1; i < COLOR_BINS.length; i++) {
        const b = COLOR_BINS[i];
        if (drop >= b.min && drop < b.max) return b.color;
      }
      return COLOR_BINS[COLOR_BINS.length - 1].color; // fallback
    }

    function style(feature) {
      const p = feature.properties || {};
      const raw = getRawDecline(p);
      return {
        fillColor: getColorForValue(raw),
        weight: 0.2,
        opacity: 0.3,
        color: "gray",
        fillOpacity: 0.9
      };
    }

    function formatNumber(n) {
      return (typeof n === "number" && isFinite(n)) ? Math.round(n).toLocaleString() : "N/A";
    }

    function onEachFeature(feature, layer) {
      const p = feature.properties || {};
      const raw = getRawDecline(p);
      const { drop, newHigh } = toDropMagnitude(raw);
      const declineText = (drop !== null)
        ? `${drop.toFixed(1)}%`
        : "N/A";

      const rank = p._rank ? `#${p._rank}` : "N/A";

      layer.bindPopup(`
        <div style="font-family: Arial, sans-serif; line-height: 1.4;">
          <h4 style="margin: 0 0 10px 0; color: #333;">${getCityName(p)}</h4>
          <strong>Province:</strong> ${p.pr_name ?? "N/A"}<br/><br/>
          <div style="background:#f5f5f5; padding:8px; border-radius:4px; margin:8px 0;">
            <strong>üèÜ Peak Year: ${p.peak_year ?? "N/A"}</strong><br/>
            <small>Peak Price: ¬•${formatNumber(p.peak_price)}/m¬≤</small>
          </div>
          <div style="background:#f0f8ff; padding:8px; border-radius:4px; margin:8px 0;">
            <strong>Decline from peak:</strong> ${newHigh ? "New High" : declineText}<br/>
            <strong>National Rank:</strong> ${newHigh ? "N/A" : rank}
          </div>
          <small>Current Price: ¬•${formatNumber(p.current_price)}/m¬≤ ¬∑ ‚è±Ô∏è ${p.years_since_peak ?? "N/A"} years since peak ¬∑ üè¢ Tier: ${p.tier ?? "N/A"}</small>
        </div>
      `, { maxWidth: 320 });
    }

    // Build legend items dynamically to match bins
    function buildLegend() {
      const box = document.getElementById("legendBox");
      const itemsHtml = COLOR_BINS.map(b => `
        <div class="legend-item">
          <div class="legend-color" style="background:${b.color};"></div>
          <span>${b.label}</span>
        </div>
      `).join("");
      box.insertAdjacentHTML("beforeend", itemsHtml);
    }

    // Stats + ranking + Top10
    function calculateStatsAndRanking(data) {
      const items = [];
      for (const f of data.features) {
        const p = f.properties || {};
        const raw = getRawDecline(p);
        const { drop, newHigh } = toDropMagnitude(raw);
        if (drop !== null && !newHigh) {
          items.push({ f, drop });
        }
      }
      // Sort by drop desc
      items.sort((a, b) => b.drop - a.drop);
      // Assign ranks
      items.forEach((it, i) => { it.f.properties._rank = i + 1; });

      // Stats
      if (items.length) {
        const declines = items.map(it => it.drop);
        const avg = declines.reduce((a, b) => a + b, 0) / declines.length;
        const severe = declines.filter(d => d >= 20).length; // >=20% drop
        const nearPeak = declines.filter(d => d < 5).length; // <5% drop

        document.getElementById("averageDecline").textContent = `Avg decline: ${avg.toFixed(1)}%`;
        document.getElementById("severeDeclines").textContent = `Severe decline (‚â•20%): ${severe} cities`;
        document.getElementById("nearPeaks").textContent = `Near peak (<5% decline): ${nearPeak} cities`;
        document.getElementById("statsPanel").style.display = "";
      }

      // Top 10 list
      const top10 = items.slice(0, 10);
      const ol = document.getElementById("top10List");
      ol.innerHTML = "";
      top10.forEach(it => {
        const name = getCityName(it.f.properties || {});
        const li = document.createElement("li");
        li.textContent = `${name}: ${it.drop.toFixed(1)}%`;
        li.style.cursor = "pointer";
        // On click in the list, open popup (if layer exists)
        li.addEventListener("click", () => {
          if (it._layer && it._layer.getBounds) {
            // Fit to city bounds and open popup
            map.fitBounds(it._layer.getBounds(), { padding: [20, 20] });
            it._layer.openPopup();
          }
        });
        ol.appendChild(li);
      });

      return items; // we return to link layers later
    }

    let map, currentLayer;

    function initMap() {
      map = L.map("map").setView([35, 105], 4);
      L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
        attribution: "¬© OpenStreetMap contributors"
      }).addTo(map);
    }

    document.addEventListener("DOMContentLoaded", () => {
      initMap();
      buildLegend();

      fetch(GEOJSON)
        .then(r => r.json())
        .then(data => {
          document.getElementById("dataStatus").textContent =
            `Total Cities: ${data.features?.length ?? 0}`;

          // Compute ranking before adding to map (so popups can use it)
          const rankedItems = calculateStatsAndRanking(data);

          // Add GeoJSON layer
          currentLayer = L.geoJSON(data, {
            style,
            onEachFeature
          }).addTo(map);

          // Connect each ranked feature to its Leaflet layer for Top10 click
          currentLayer.eachLayer(layer => {
            const f = layer.feature;
            // find corresponding ranked item by object reference
            const match = rankedItems.find(it => it.f === f);
            if (match) match._layer = layer;
          });

          // Fit bounds
          if (currentLayer.getBounds().isValid()) {
            map.fitBounds(currentLayer.getBounds(), { padding: [20, 20] });
          }
        })
        .catch(err => {
          console.error(err);
          document.getElementById("dataStatus").textContent = "‚ùå Failed to load data";
        });
    });
  </script>
</body>
</html>
